pack "betterworldedit" "Generated by MDL CLI" 82;
namespace "betterworldedit";

// Variables
// Selection state per-player
var num bwe_pos1_x<@a> = 0;
var num bwe_pos1_y<@a> = 0;
var num bwe_pos1_z<@a> = 0;
var num bwe_pos2_x<@a> = 0;
var num bwe_pos2_y<@a> = 0;
var num bwe_pos2_z<@a> = 0;
var num bwe_pos1_set<@a> = 0;
var num bwe_pos2_set<@a> = 0;

// Derived bounds/dimensions per-player
var num bwe_min_x<@a> = 0;
var num bwe_min_y<@a> = 0;
var num bwe_min_z<@a> = 0;
var num bwe_max_x<@a> = 0;
var num bwe_max_y<@a> = 0;
var num bwe_max_z<@a> = 0;
var num bwe_dim_x<@a> = 0;
var num bwe_dim_y<@a> = 0;
var num bwe_dim_z<@a> = 0;
var num bwe_volume<@a> = 0;

// Config per-player (avoid global entity dependency)
var num bwe_max_fill<@a> = 30000; // safe default under vanilla fill cap
var num bwe_outline_enabled<@a> = 0;
var num bwe_outline_step<@a> = 1;

// Scratch variables (per-player) used in helpers/loops
var num _px<@a> = 0; // particle x
var num _py<@a> = 0; // particle y
var num _pz<@a> = 0; // particle z
var num _x<@a> = 0;
var num _y<@a> = 0;
var num _z<@a> = 0;
var num _mx<@a> = 0;
var num _yb<@a> = 0; // bottom y
var num _yt<@a> = 0; // top y
var num _slice_h<@a> = 0;
var num _base<@a> = 0;
var num _slices<@a> = 0;
var num _y_start<@a> = 0;
var num _y_end<@a> = 0;

// Selector item usage tracking (two-tool system via custom_data: bwe_selector_1 / bwe_selector_2)
var num bwe_stat_selector<@a> = 0;      // current brush use stat (mirrors objective)
var num bwe_stat_selector_2<@a> = 0;    // mirror for clarity/debug (same value as above)
var num bwe_stat_prev_1<@a> = 0;        // last seen stat when using Pos1 tool
var num bwe_stat_prev_2<@a> = 0;        // last seen stat when using Pos2 tool
// Sneak-based toggling removed; each tool maps directly to pos1/pos2

// Additional scratch for chunked tiling
var num _xs<@a> = 0;
var num _xe<@a> = 0;
var num _zs<@a> = 0;
var num _ze<@a> = 0;
var num _tile_x<@a> = 0;
var num _tile_z<@a> = 0;
var num _area_limit<@a> = 0;

// Main function
function betterworldedit:main {
    say "BetterWorldEdit - Commands:";
    say " - /function betterworldedit:pos1 - set position 1";
    say " - /function betterworldedit:pos2 - set position 2";
    say " - /function betterworldedit:outline_toggle - toggle outlines";
    say " - /function betterworldedit:info - show selection info";
    say " - /function betterworldedit:set_stone - fill selection with stone (chunked)";
    say " - /function betterworldedit:give_selector - get selector tools (pos1 & pos2)";
    say " - exec betterworldedit:fill_selection '{block:\"minecraft:oak_planks\"}' - fill with any block";
    say "Selector Tools:";
    say " - Blue tool: right-click = pos1";
    say " - Gold tool: right-click = pos2";
}

// Init function (avoid reserved names like 'load' or 'tick')
function betterworldedit:init {
    say "BetterWorldEdit initialized. Run /function betterworldedit:main";
    // Ensure selector stat objective exists (brush usage)
    $!raw
    scoreboard objectives add bwe_use_selector minecraft.used:minecraft.brush
    raw!$
}

// Hook to run on load
on_load betterworldedit:init;

// --- Position capture helpers ---

function betterworldedit:pos1 {
    // Capture player's current block coordinates into pos1
    $!raw
    execute store result score @s bwe_pos1_x run data get entity @s Pos[0] 1
    execute store result score @s bwe_pos1_y run data get entity @s Pos[1] 1
    execute store result score @s bwe_pos1_z run data get entity @s Pos[2] 1
    raw!$
    bwe_pos1_set<@s> = 1;
    $!raw
    tellraw @s [{"text":"Set pos1 to ("},{"score":{"name":"@s","objective":"bwe_pos1_x"}},{"text":", "},{"score":{"name":"@s","objective":"bwe_pos1_y"}},{"text":", "},{"score":{"name":"@s","objective":"bwe_pos1_z"}},{"text":")"}]
    raw!$
}

function betterworldedit:pos2 {
    // Capture player's current block coordinates into pos2
    $!raw
    execute store result score @s bwe_pos2_x run data get entity @s Pos[0] 1
    execute store result score @s bwe_pos2_y run data get entity @s Pos[1] 1
    execute store result score @s bwe_pos2_z run data get entity @s Pos[2] 1
    raw!$
    bwe_pos2_set<@s> = 1;
    $!raw
    tellraw @s [{"text":"Set pos2 to ("},{"score":{"name":"@s","objective":"bwe_pos2_x"}},{"text":", "},{"score":{"name":"@s","objective":"bwe_pos2_y"}},{"text":", "},{"score":{"name":"@s","objective":"bwe_pos2_z"}},{"text":")"}]
    raw!$
}

// --- Bounds, dimensions, and info ---

function betterworldedit:_compute_bounds {
    // If one pos not set, mirror the other so dims stay valid
    if $bwe_pos1_set<@s>$ == 0 {
        bwe_pos1_x<@s> = $bwe_pos2_x<@s>$;
        bwe_pos1_y<@s> = $bwe_pos2_y<@s>$;
        bwe_pos1_z<@s> = $bwe_pos2_z<@s>$;
    }
    if $bwe_pos2_set<@s>$ == 0 {
        bwe_pos2_x<@s> = $bwe_pos1_x<@s>$;
        bwe_pos2_y<@s> = $bwe_pos1_y<@s>$;
        bwe_pos2_z<@s> = $bwe_pos1_z<@s>$;
    }

    // X bounds
    if $bwe_pos1_x<@s>$ <= $bwe_pos2_x<@s>$ {
        bwe_min_x<@s> = $bwe_pos1_x<@s>$;
        bwe_max_x<@s> = $bwe_pos2_x<@s>$;
    } else {
        bwe_min_x<@s> = $bwe_pos2_x<@s>$;
        bwe_max_x<@s> = $bwe_pos1_x<@s>$;
    }
    // Y bounds
    if $bwe_pos1_y<@s>$ <= $bwe_pos2_y<@s>$ {
        bwe_min_y<@s> = $bwe_pos1_y<@s>$;
        bwe_max_y<@s> = $bwe_pos2_y<@s>$;
    } else {
        bwe_min_y<@s> = $bwe_pos2_y<@s>$;
        bwe_max_y<@s> = $bwe_pos1_y<@s>$;
    }
    // Z bounds
    if $bwe_pos1_z<@s>$ <= $bwe_pos2_z<@s>$ {
        bwe_min_z<@s> = $bwe_pos1_z<@s>$;
        bwe_max_z<@s> = $bwe_pos2_z<@s>$;
    } else {
        bwe_min_z<@s> = $bwe_pos2_z<@s>$;
        bwe_max_z<@s> = $bwe_pos1_z<@s>$;
    }

    // Dimensions (inclusive)
    bwe_dim_x<@s> = $bwe_max_x<@s>$ - $bwe_min_x<@s>$ + 1;
    bwe_dim_y<@s> = $bwe_max_y<@s>$ - $bwe_min_y<@s>$ + 1;
    bwe_dim_z<@s> = $bwe_max_z<@s>$ - $bwe_min_z<@s>$ + 1;

    // Volume
    bwe_volume<@s> = $bwe_dim_x<@s>$ * $bwe_dim_y<@s>$ * $bwe_dim_z<@s>$;
}

function betterworldedit:info {
    exec betterworldedit:_compute_bounds;
    say "Pos1: ($bwe_pos1_x<@s>$, $bwe_pos1_y<@s>$, $bwe_pos1_z<@s>$)";
    say "Pos2: ($bwe_pos2_x<@s>$, $bwe_pos2_y<@s>$, $bwe_pos2_z<@s>$)";
    say "Bounds min: ($bwe_min_x<@s>$, $bwe_min_y<@s>$, $bwe_min_z<@s>$) max: ($bwe_max_x<@s>$, $bwe_max_y<@s>$, $bwe_max_z<@s>$)";
    say "Dims: $bwe_dim_x<@s>$ x $bwe_dim_y<@s>$ x $bwe_dim_z<@s>$ = $bwe_volume<@s>$";
}

// --- Outline rendering ---

function betterworldedit:outline_toggle {
    if $bwe_outline_enabled<@s>$ == 1 {
        bwe_outline_enabled<@s> = 0;
        say "Outlines disabled.";
    } else {
        bwe_outline_enabled<@s> = 1;
        say "Outlines enabled.";
    }
}

function betterworldedit:_outline_once {
    exec betterworldedit:_compute_bounds;

    // Compute a simple step to avoid spamming too many particles
    // step = max(1, ceil(max(dim) / 64)) approximated as (max+63)/64
    _mx<@s> = $bwe_dim_x<@s>$;
    if $bwe_dim_y<@s>$ > $_mx<@s>$ { _mx<@s> = $bwe_dim_y<@s>$; }
    if $bwe_dim_z<@s>$ > $_mx<@s>$ { _mx<@s> = $bwe_dim_z<@s>$; }
    // For 1.20.5+ compatibility, set outline step to 1 to avoid divide operation
    bwe_outline_step<@s> = 1;
    // Remove the old divide calculation that causes parse errors

    _yb<@s> = $bwe_min_y<@s>$;
    _yt<@s> = $bwe_max_y<@s>$;

    // Bottom rectangle edges (y = min_y)
    _x<@s> = $bwe_min_x<@s>$;
    while $_x<@s>$ <= $bwe_max_x<@s>$ {
        _px<@s> = $_x<@s>$; _py<@s> = $_yb<@s>$; _pz<@s> = $bwe_min_z<@s>$; exec betterworldedit:_emit_particle_from_scores;
        _px<@s> = $_x<@s>$; _py<@s> = $_yb<@s>$; _pz<@s> = $bwe_max_z<@s>$; exec betterworldedit:_emit_particle_from_scores;
        _x<@s> = $_x<@s>$ + $bwe_outline_step<@s>$;
    }
    _z<@s> = $bwe_min_z<@s>$;
    while $_z<@s>$ <= $bwe_max_z<@s>$ {
        _px<@s> = $bwe_min_x<@s>$; _py<@s> = $_yb<@s>$; _pz<@s> = $_z<@s>$; exec betterworldedit:_emit_particle_from_scores;
        _px<@s> = $bwe_max_x<@s>$; _py<@s> = $_yb<@s>$; _pz<@s> = $_z<@s>$; exec betterworldedit:_emit_particle_from_scores;
        _z<@s> = $_z<@s>$ + $bwe_outline_step<@s>$;
    }

    // Top rectangle edges (y = max_y)
    _x<@s> = $bwe_min_x<@s>$;
    while $_x<@s>$ <= $bwe_max_x<@s>$ {
        _px<@s> = $_x<@s>$; _py<@s> = $_yt<@s>$; _pz<@s> = $bwe_min_z<@s>$; exec betterworldedit:_emit_particle_from_scores;
        _px<@s> = $_x<@s>$; _py<@s> = $_yt<@s>$; _pz<@s> = $bwe_max_z<@s>$; exec betterworldedit:_emit_particle_from_scores;
        _x<@s> = $_x<@s>$ + $bwe_outline_step<@s>$;
    }
    _z<@s> = $bwe_min_z<@s>$;
    while $_z<@s>$ <= $bwe_max_z<@s>$ {
        _px<@s> = $bwe_min_x<@s>$; _py<@s> = $_yt<@s>$; _pz<@s> = $_z<@s>$; exec betterworldedit:_emit_particle_from_scores;
        _px<@s> = $bwe_max_x<@s>$; _py<@s> = $_yt<@s>$; _pz<@s> = $_z<@s>$; exec betterworldedit:_emit_particle_from_scores;
        _z<@s> = $_z<@s>$ + $bwe_outline_step<@s>$;
    }

    // Vertical edges at corners
    _y<@s> = $bwe_min_y<@s>$;
    while $_y<@s>$ <= $bwe_max_y<@s>$ {
        _px<@s> = $bwe_min_x<@s>$; _py<@s> = $_y<@s>$; _pz<@s> = $bwe_min_z<@s>$; exec betterworldedit:_emit_particle_from_scores;
        _px<@s> = $bwe_min_x<@s>$; _py<@s> = $_y<@s>$; _pz<@s> = $bwe_max_z<@s>$; exec betterworldedit:_emit_particle_from_scores;
        _px<@s> = $bwe_max_x<@s>$; _py<@s> = $_y<@s>$; _pz<@s> = $bwe_min_z<@s>$; exec betterworldedit:_emit_particle_from_scores;
        _px<@s> = $bwe_max_x<@s>$; _py<@s> = $_y<@s>$; _pz<@s> = $bwe_max_z<@s>$; exec betterworldedit:_emit_particle_from_scores;
        _y<@s> = $_y<@s>$ + $bwe_outline_step<@s>$;
    }
}

// Outline particle macro and emitter
function betterworldedit:_particle_macro {
    $particle minecraft:dust 0 1 1 1 $(x) $(y) $(z) 0 0 0 0 1 force @s
}

function betterworldedit:_emit_particle_from_scores {
    $!raw
    data remove storage betterworldedit:ctx p
    data modify storage betterworldedit:ctx p set value {}
    execute store result storage betterworldedit:ctx p.x int 1 run scoreboard players get @s _px
    execute store result storage betterworldedit:ctx p.y int 1 run scoreboard players get @s _py
    execute store result storage betterworldedit:ctx p.z int 1 run scoreboard players get @s _pz
    raw!$
    exec betterworldedit:_particle_macro with storage betterworldedit:ctx p;
}

function betterworldedit:update_outline {
    if $bwe_outline_enabled<@s>$ == 1 {
        exec betterworldedit:_outline_once;
    }
}

function betterworldedit:_ensure_scores_for_player {
    $!raw
    # Flags & positions
    scoreboard players add @s bwe_pos1_set 0
    scoreboard players add @s bwe_pos2_set 0
    scoreboard players add @s bwe_pos1_x 0
    scoreboard players add @s bwe_pos1_y 0
    scoreboard players add @s bwe_pos1_z 0
    scoreboard players add @s bwe_pos2_x 0
    scoreboard players add @s bwe_pos2_y 0
    scoreboard players add @s bwe_pos2_z 0

    # Derived
    scoreboard players add @s bwe_min_x 0
    scoreboard players add @s bwe_min_y 0
    scoreboard players add @s bwe_min_z 0
    scoreboard players add @s bwe_max_x 0
    scoreboard players add @s bwe_max_y 0
    scoreboard players add @s bwe_max_z 0
    scoreboard players add @s bwe_dim_x 0
    scoreboard players add @s bwe_dim_y 0
    scoreboard players add @s bwe_dim_z 0
    scoreboard players add @s bwe_volume 0

    # Config
    scoreboard players add @s bwe_max_fill 30000
    scoreboard players add @s bwe_outline_enabled 0
    scoreboard players add @s bwe_outline_step 1

    # Scratch used in prints/loops to avoid blanks
    scoreboard players add @s _px 0
    scoreboard players add @s _py 0
    scoreboard players add @s _pz 0
    scoreboard players add @s _x 0
    scoreboard players add @s _y 0
    scoreboard players add @s _z 0
    scoreboard players add @s _mx 0
    scoreboard players add @s _yb 0
    scoreboard players add @s _yt 0
    scoreboard players add @s _slice_h 1
    scoreboard players add @s _base 0
    scoreboard players add @s _slices 0
    scoreboard players add @s _y_start 0
    scoreboard players add @s _y_end 0
    scoreboard players add @s _xs 0
    scoreboard players add @s _xe 0
    scoreboard players add @s _zs 0
    scoreboard players add @s _ze 0
    raw!$
}

// Central tick: outlines and selector handling
function betterworldedit:main_tick {
    exec betterworldedit:_ensure_scores_for_player<@a>;
    exec betterworldedit:update_outline<@a>;
    exec betterworldedit:update_selector<@a>;
}

on_tick betterworldedit:main_tick;

// --- Chunked fill ---

// Macro function: emits a fill command using macro placeholders set in storage compound
function betterworldedit:_fill_slice_macro {
    $fill $(x1) $(y1) $(z1) $(x2) $(y2) $(z2) $(block)
}

// Internal: set storage compound betterworldedit:ctx fill with current slice and requested block id
function betterworldedit:_prepare_fill_ctx {
    $!raw
    # Reset compound
    data remove storage betterworldedit:ctx fill
    data modify storage betterworldedit:ctx fill set value {}
    # Coords from scoreboard
    execute store result storage betterworldedit:ctx fill.x1 int 1 run scoreboard players get @s _xs
    execute store result storage betterworldedit:ctx fill.y1 int 1 run scoreboard players get @s _y_start
    execute store result storage betterworldedit:ctx fill.z1 int 1 run scoreboard players get @s _zs
    execute store result storage betterworldedit:ctx fill.x2 int 1 run scoreboard players get @s _xe
    execute store result storage betterworldedit:ctx fill.y2 int 1 run scoreboard players get @s _y_end
    execute store result storage betterworldedit:ctx fill.z2 int 1 run scoreboard players get @s _ze
    # Block id from request
    data modify storage betterworldedit:ctx fill.block set from storage betterworldedit:ctx req.block
    raw!$
}

function betterworldedit:set_stone {
    exec betterworldedit:_compute_bounds;
    say "Filling selection with stone... ($bwe_dim_x<@s>$x$bwe_dim_y<@s>$x$bwe_dim_z<@s>$ = $bwe_volume<@s>$)";

    // If within limit, single fill
    if $bwe_volume<@s>$ <= $bwe_max_fill<@s>$ {
        // Prepare single-slice context using y_start = min_y, y_end = max_y
        $!raw
        scoreboard players operation @s _y_start = @s bwe_min_y
        scoreboard players operation @s _y_end = @s bwe_max_y
        scoreboard players operation @s _xs = @s bwe_min_x
        scoreboard players operation @s _xe = @s bwe_max_x
        scoreboard players operation @s _zs = @s bwe_min_z
        scoreboard players operation @s _ze = @s bwe_max_z
        raw!$
        exec betterworldedit:_prepare_fill_ctx;
        exec betterworldedit:_fill_slice_macro with storage betterworldedit:ctx fill;
        say "Done (single fill).";
    } else {
        // Compute per-slice height: clamp to >=1 and <= dim_y
        _base<@s> = $bwe_dim_x<@s>$ * $bwe_dim_z<@s>$;
        _slice_h<@s> = $bwe_max_fill<@s>$ / $_base<@s>$;
        if $_slice_h<@s>$ < 1 { _slice_h<@s> = 1; }
        if $_slice_h<@s>$ > $bwe_dim_y<@s>$ { _slice_h<@s> = $bwe_dim_y<@s>$; }

        _y_start<@s> = $bwe_min_y<@s>$ + 0;
        _y_end<@s> = 0;
        _slices<@s> = 0;

        while $_y_start<@s>$ <= $bwe_max_y<@s>$ {
            _y_end<@s> = $_y_start<@s>$ + $_slice_h<@s>$ - 1;
            if $_y_end<@s>$ > $bwe_max_y<@s>$ { _y_end<@s> = $bwe_max_y<@s>$; }

            // Determine tile sizes along X/Z to respect area_limit
            _area_limit<@s> = $bwe_max_fill<@s>$ / $_slice_h<@s>$;
            if $_area_limit<@s>$ < 1 { _area_limit<@s> = 1; }

            _tile_x<@s> = $_area_limit<@s>$ / $bwe_dim_z<@s>$;
            if $_tile_x<@s>$ < 1 { _tile_x<@s> = 1; }
            if $_tile_x<@s>$ > $bwe_dim_x<@s>$ { _tile_x<@s> = $bwe_dim_x<@s>$; }
            _tile_z<@s> = $_area_limit<@s>$ / $_tile_x<@s>$;
            if $_tile_z<@s>$ < 1 { _tile_z<@s> = 1; }
            if $_tile_z<@s>$ > $bwe_dim_z<@s>$ { _tile_z<@s> = $bwe_dim_z<@s>$; }

            _xs<@s> = $bwe_min_x<@s>$ + 0;
            while $_xs<@s>$ <= $bwe_max_x<@s>$ {
                _xe<@s> = $_xs<@s>$ + $_tile_x<@s>$ - 1;
                if $_xe<@s>$ > $bwe_max_x<@s>$ { _xe<@s> = $bwe_max_x<@s>$; }
                _zs<@s> = $bwe_min_z<@s>$ + 0;
                while $_zs<@s>$ <= $bwe_max_z<@s>$ {
                    _ze<@s> = $_zs<@s>$ + $_tile_z<@s>$ - 1;
                    if $_ze<@s>$ > $bwe_max_z<@s>$ { _ze<@s> = $bwe_max_z<@s>$; }
                    exec betterworldedit:_prepare_fill_ctx;
                    exec betterworldedit:_fill_slice_macro with storage betterworldedit:ctx fill;
                    _slices<@s> = $_slices<@s>$ + 1;
                    say "Filled #$_slices<@s>$: x $_xs<@s>$..$_xe<@s>$, y $_y_start<@s>$..$_y_end<@s>$, z $_zs<@s>$..$_ze<@s>$";
                    _zs<@s> = $_ze<@s>$ + 1;
                }
                _xs<@s> = $_xe<@s>$ + 1;
            }
            _y_start<@s> = $_y_end<@s>$ + 1;
        }
        say "Done ($_slices<@s>$ sub-fills).";
    }
}

// Public macro: set requested block (string) and run chunked fill over current selection
// Usage examples:
//   exec betterworldedit:fill_selection '{block:"minecraft:oak_planks"}';
//   exec betterworldedit:fill_selection with storage betterworldedit:req mypath.to.compound;
function betterworldedit:fill_selection {
    $!raw
    data remove storage betterworldedit:ctx req
    data modify storage betterworldedit:ctx req set value {}
    data modify storage betterworldedit:ctx req.block set value "$(block)"
    raw!$
    exec betterworldedit:set_stone;
}

// --- Selector item (super easy) ---

function betterworldedit:give_selector {
    $!raw
    give @s minecraft:brush[item_name={"bold":true,"color":"dark_blue","italic":true,"text":"BWE Selector (Pos1)"},lore=[{"text":"Right-click: set pos1","color":"gray","italic":false}],custom_data={bwe_selector_1:1b}] 1
    give @s minecraft:brush[item_name={"bold":true,"color":"gold","italic":true,"text":"BWE Selector (Pos2)"},lore=[{"text":"Right-click: set pos2","color":"gray","italic":false}],custom_data={bwe_selector_2:1b}] 1
    raw!$
    say "Gave you both BWE Selector tools (pos1 and pos2).";
}

function betterworldedit:update_selector {
    // Update tags based on currently held selector tool
    $!raw
    tag @s remove bwe_holding_pos1
    tag @s remove bwe_holding_pos2
    execute if entity @s[nbt={SelectedItem:{components:{"minecraft:custom_data":{bwe_selector_1:1b}}}}] run tag @s add bwe_holding_pos1
    execute if entity @s[nbt={SelectedItem:{components:{"minecraft:custom_data":{bwe_selector_2:1b}}}}] run tag @s add bwe_holding_pos2
    raw!$

    // On brush use, run the appropriate function for whoever holds that tool, then reset the stat
    $!raw
    execute as @s[tag=bwe_holding_pos1,scores={bwe_use_selector=1..}] run function betterworldedit:pos1
    execute as @s[tag=bwe_holding_pos2,scores={bwe_use_selector=1..}] run function betterworldedit:pos2
    scoreboard players reset @s[scores={bwe_use_selector=1..}] bwe_use_selector
    raw!$
}

// Simple two-tool system: one tool for pos1, one tool for pos2
