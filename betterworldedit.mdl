pack "betterworldedit" "Generated by MDL CLI" 82;
namespace "betterworldedit";

// =============================
// Variables
// =============================

// Selection state per-player
var num bwe_pos1_x<@a> = 0;
var num bwe_pos1_y<@a> = 0;
var num bwe_pos1_z<@a> = 0;
var num bwe_pos2_x<@a> = 0;
var num bwe_pos2_y<@a> = 0;
var num bwe_pos2_z<@a> = 0;
var num bwe_pos1_set<@a> = 0;
var num bwe_pos2_set<@a> = 0;

// Derived bounds/dimensions per-player
var num bwe_min_x<@a> = 0;
var num bwe_min_y<@a> = 0;
var num bwe_min_z<@a> = 0;
var num bwe_max_x<@a> = 0;
var num bwe_max_y<@a> = 0;
var num bwe_max_z<@a> = 0;
var num bwe_dim_x<@a> = 0;
var num bwe_dim_y<@a> = 0;
var num bwe_dim_z<@a> = 0;
var num bwe_volume<@a> = 0;

// Config per-player
var num bwe_max_fill<@a> = 30000; // safe default under vanilla fill cap

// Scratch variables (per-player) used in helpers/loops
var num _slice_h<@a> = 0;
var num _slices<@a> = 0;
var num _y_start<@a> = 0;
var num _y_end<@a> = 0;
var num _xs<@a> = 0;
var num _xe<@a> = 0;
var num _zs<@a> = 0;
var num _ze<@a> = 0;
var num _tile_x<@a> = 0;
var num _tile_z<@a> = 0;
var num _temp<@a> = 0;
var num _ix<@a> = 0;
var num _iy<@a> = 0;
var num _iz<@a> = 0;
var num _fill_active<@a> = 0;
var num _fill_desc<@a> = 0;

// Operation mode: 1=solid, 2=hollow faces, 3=outline edges
var num _op_mode<@a> = 0;

// Hollow-face tiling state
var num _fi<@a> = 0;        // face index 0..5
var num _u_idx<@a> = 0;
var num _v_idx<@a> = 0;
var num _tile_u<@a> = 0;
var num _tile_v<@a> = 0;
var num _us<@a> = 0;
var num _ue<@a> = 0;
var num _vs<@a> = 0;
var num _ve<@a> = 0;

// Outline edges tiling state
var num _ej<@a> = 0;        // edge index 0..11
var num _seg_idx<@a> = 0;   // segment index along edge

// Mask mode: 0=all, 1=keep, 2=destroy, 3=replace(filter)
var num _mask_mode<@a> = 0;

// Selector item usage tracking (two-tool system via custom_data: bwe_selector_1 / bwe_selector_2)
var num bwe_stat_selector<@a> = 0;      // current brush use stat (mirrors objective)
var num bwe_stat_selector_2<@a> = 0;    // mirror for clarity/debug (same value as above)
var num bwe_stat_prev_1<@a> = 0;        // last seen stat when using Pos1 tool
var num bwe_stat_prev_2<@a> = 0;        // last seen stat when using Pos2 tool

// =============================
// Main / Init
// =============================

function betterworldedit:help {
    $!raw
    tellraw @s [{"text":"BetterWorldEdit","bold":true,"color":"aqua"},{"text":" - Commands","color":"gray"}]
    tellraw @s [{"text":"/function betterworldedit:pos1","color":"gold"},{"text":" - set position 1 (your current block)","color":"yellow"}]
    tellraw @s [{"text":"/function betterworldedit:pos2","color":"gold"},{"text":" - set position 2 (your current block)","color":"yellow"}]
    tellraw @s [{"text":"/function betterworldedit:info","color":"gold"},{"text":" - show selection info","color":"yellow"}]
    tellraw @s [{"text":"/function betterworldedit:fill ","color":"gold"},{"text":"{block:\"minecraft:oak_planks\",mask:{mode:\"keep\"}}","color":"aqua"},{"text":" - fill solid (supports mask)","color":"yellow"}]
    tellraw @s [{"text":"/function betterworldedit:fill_hollow ","color":"gold"},{"text":"{block:\"minecraft:oak_planks\",mask:{mode:\"replace\",filter:\"minecraft:stone\"}}","color":"aqua"},{"text":" - shell only (no seams)","color":"yellow"}]
    tellraw @s [{"text":"/function betterworldedit:fill_outline ","color":"gold"},{"text":"{block:\"minecraft:oak_planks\"}}","color":"aqua"},{"text":" - edges & corners only","color":"yellow"}]
    tellraw @s [{"text":"Mask modes: ","color":"gray"},{"text":"all","color":"white"},{"text":", ","color":"gray"},{"text":"keep","color":"white"},{"text":", ","color":"gray"},{"text":"destroy","color":"white"},{"text":", ","color":"gray"},{"text":"replace(filter)","color":"white"}]
    tellraw @s [{"text":"Example replace-tag: ","color":"gray"},{"text":"mask:{mode:\"replace\",filter:\"#minecraft:leaves\"}","color":"aqua"}]
    tellraw @s [{"text":"/function betterworldedit:give_selector","color":"gold"},{"text":" - get selector tools (pos1 & pos2)","color":"yellow"}]
    tellraw @s [{"text":"/function betterworldedit:set_max_fill ","color":"gold"},{"text":"{value:30000}","color":"aqua"},{"text":" - set max blocks per sub-fill","color":"yellow"}]
    tellraw @s [{"text":"/function betterworldedit:set_topdown_mode ","color":"gold"},{"text":"{mode:0}","color":"aqua"},{"text":" - set top-down fill mode","color":"yellow"}]
    tellraw @s [{"text":"Top-down modes: ","color":"gray"},{"text":"0=air only","color":"white"},{"text":", ","color":"gray"},{"text":"1=liquids+air","color":"white"},{"text":", ","color":"gray"},{"text":"2=all blocks","color":"white"}]
    tellraw @s [{"text":"Global config: ","color":"gray"},{"text":"armor stand tag ","color":"dark_gray"},{"text":"bwe_global_config","color":"aqua"},{"text":" controls settings.","color":"gray"}]
    raw!$
}

function betterworldedit:init {
    $!raw tellraw @a [{"text":"BetterWorldEdit initialized. Run ","color":"gray"},{"text":"/function betterworldedit:help","color":"aqua"},{"text":".","color":"gray"}]raw!$
    // Scoreboard objectives
    $!raw
    scoreboard objectives add bwe_use_selector minecraft.used:minecraft.brush

    scoreboard objectives add bwe_pos1_x dummy
    scoreboard objectives add bwe_pos1_y dummy
    scoreboard objectives add bwe_pos1_z dummy
    scoreboard objectives add bwe_pos2_x dummy
    scoreboard objectives add bwe_pos2_y dummy
    scoreboard objectives add bwe_pos2_z dummy
    scoreboard objectives add bwe_pos1_set dummy
    scoreboard objectives add bwe_pos2_set dummy

    scoreboard objectives add bwe_min_x dummy
    scoreboard objectives add bwe_min_y dummy
    scoreboard objectives add bwe_min_z dummy
    scoreboard objectives add bwe_max_x dummy
    scoreboard objectives add bwe_max_y dummy
    scoreboard objectives add bwe_max_z dummy
    scoreboard objectives add bwe_dim_x dummy
    scoreboard objectives add bwe_dim_y dummy
    scoreboard objectives add bwe_dim_z dummy
    scoreboard objectives add bwe_volume dummy

    scoreboard objectives add bwe_max_fill dummy

    scoreboard objectives add _slice_h dummy
    scoreboard objectives add _slices dummy
    scoreboard objectives add _y_start dummy
    scoreboard objectives add _y_end dummy
    scoreboard objectives add _xs dummy
    scoreboard objectives add _xe dummy
    scoreboard objectives add _zs dummy
    scoreboard objectives add _ze dummy
    scoreboard objectives add _tile_x dummy
    scoreboard objectives add _tile_z dummy
    scoreboard objectives add _temp dummy
    scoreboard objectives add _ix dummy
    scoreboard objectives add _iy dummy
    scoreboard objectives add _iz dummy
    scoreboard objectives add _fill_active dummy
    scoreboard objectives add _fill_desc dummy

    scoreboard objectives add _op_mode dummy

    scoreboard objectives add _fi dummy
    scoreboard objectives add _u_idx dummy
    scoreboard objectives add _v_idx dummy
    scoreboard objectives add _tile_u dummy
    scoreboard objectives add _tile_v dummy
    scoreboard objectives add _us dummy
    scoreboard objectives add _ue dummy
    scoreboard objectives add _vs dummy
    scoreboard objectives add _ve dummy

    scoreboard objectives add _ej dummy
    scoreboard objectives add _seg_idx dummy

    scoreboard objectives add _mask_mode dummy

    scoreboard objectives add bwe_stat_selector dummy
    scoreboard objectives add bwe_stat_selector_2 dummy
    scoreboard objectives add bwe_stat_prev_1 dummy
    scoreboard objectives add bwe_stat_prev_2 dummy

    scoreboard objectives add bwe_topdown_mode dummy
    raw!$
}

// Run on load
on_load betterworldedit:init;

function betterworldedit:_ensure_global_config {
    $!raw
    # Ensure a single invulnerable, no-gravity armor stand exists with config scores
    execute unless entity @e[type=armor_stand,tag=bwe_global_config,limit=1] run summon armor_stand ~ ~ ~ {NoGravity:1b,Invulnerable:1b,Invisible:1b,Tags:["bwe_global_config"],CustomName:'{"text":"BWE Global Config","color":"aqua"}'}

    # Ensure the objective exists for global max fill
    scoreboard objectives add bwe_max_fill dummy

    # Initialize default if missing
    scoreboard players add @e[type=armor_stand,tag=bwe_global_config] bwe_max_fill 0
    execute unless score @e[type=armor_stand,tag=bwe_global_config,limit=1] bwe_max_fill matches 1.. run scoreboard players set @e[type=armor_stand,tag=bwe_global_config,limit=1] bwe_max_fill 30000

    # Ensure objective exists for top-down fill mode configuration
    scoreboard objectives add bwe_topdown_mode dummy

    # Initialize top-down mode: 0=air only (default), 1=liquids+air, 2=all blocks
    scoreboard players add @e[type=armor_stand,tag=bwe_global_config] bwe_topdown_mode 0
    raw!$
}

function betterworldedit:_determine_fill_direction {
    $!raw
    # Default to bottom-up (ascending) fill
    scoreboard players set @s _fill_desc 0
    
    # Get the global top-down mode setting
    execute store result score @s _temp run scoreboard players get @e[type=armor_stand,tag=bwe_global_config,limit=1] bwe_topdown_mode
    
    # Mode 0: Air only (default behavior)
    execute if score @s _temp matches 0 if data storage betterworldedit:ctx req{block:"minecraft:air"} run scoreboard players set @s _fill_desc 1
    
    # Mode 1: Liquids and air
    execute if score @s _temp matches 1 if data storage betterworldedit:ctx req{block:"minecraft:air"} run scoreboard players set @s _fill_desc 1
    execute if score @s _temp matches 1 if data storage betterworldedit:ctx req{block:"minecraft:water"} run scoreboard players set @s _fill_desc 1
    execute if score @s _temp matches 1 if data storage betterworldedit:ctx req{block:"minecraft:lava"} run scoreboard players set @s _fill_desc 1
    
    # Mode 2: All blocks fill top-down
    execute if score @s _temp matches 2 run scoreboard players set @s _fill_desc 1
    raw!$
}

// =============================
// Position capture helpers
// =============================

function betterworldedit:pos1 {
    // Capture player's current block coordinates into pos1
    $!raw
    execute store result score @s bwe_pos1_x run data get entity @s Pos[0] 1
    execute store result score @s bwe_pos1_y run data get entity @s Pos[1] 1
    execute store result score @s bwe_pos1_z run data get entity @s Pos[2] 1
    # Off-by-one fix: if feet are in air, choose block below
    execute if block ~ ~ ~ #minecraft:air run scoreboard players remove @s bwe_pos1_y 1
    raw!$
    bwe_pos1_set<@s> = 1;
    $!raw
    tellraw @s [{"text":"Pos1 set ","color":"green"},{"text":"(","color":"dark_gray"},{"score":{"name":"@s","objective":"bwe_pos1_x"},"color":"aqua"},{"text":", ","color":"dark_gray"},{"score":{"name":"@s","objective":"bwe_pos1_y"},"color":"aqua"},{"text":", ","color":"dark_gray"},{"score":{"name":"@s","objective":"bwe_pos1_z"},"color":"aqua"},{"text":")","color":"dark_gray"}]
    raw!$
}

function betterworldedit:pos2 {
    // Capture player's current block coordinates into pos2
    $!raw
    execute store result score @s bwe_pos2_x run data get entity @s Pos[0] 1
    execute store result score @s bwe_pos2_y run data get entity @s Pos[1] 1
    execute store result score @s bwe_pos2_z run data get entity @s Pos[2] 1
    # Off-by-one fix: if feet are in air, choose block below
    execute if block ~ ~ ~ #minecraft:air run scoreboard players remove @s bwe_pos2_y 1
    raw!$
    bwe_pos2_set<@s> = 1;
    $!raw
    tellraw @s [{"text":"Pos2 set ","color":"gold"},{"text":"(","color":"dark_gray"},{"score":{"name":"@s","objective":"bwe_pos2_x"},"color":"aqua"},{"text":", ","color":"dark_gray"},{"score":{"name":"@s","objective":"bwe_pos2_y"},"color":"aqua"},{"text":", ","color":"dark_gray"},{"score":{"name":"@s","objective":"bwe_pos2_z"},"color":"aqua"},{"text":")","color":"dark_gray"}]
    raw!$
}

// =============================
// Bounds, dimensions, and info
// =============================

function betterworldedit:_compute_bounds {
    // Mirror missing positions so dims stay valid
    if $bwe_pos1_set<@s>$ == 0 {
        bwe_pos1_x<@s> = $bwe_pos2_x<@s>$;
        bwe_pos1_y<@s> = $bwe_pos2_y<@s>$;
        bwe_pos1_z<@s> = $bwe_pos2_z<@s>$;
    }
    if $bwe_pos2_set<@s>$ == 0 {
        bwe_pos2_x<@s> = $bwe_pos1_x<@s>$;
        bwe_pos2_y<@s> = $bwe_pos1_y<@s>$;
        bwe_pos2_z<@s> = $bwe_pos1_z<@s>$;
    }

    // X bounds
    if $bwe_pos1_x<@s>$ <= $bwe_pos2_x<@s>$ {
        bwe_min_x<@s> = $bwe_pos1_x<@s>$;
        bwe_max_x<@s> = $bwe_pos2_x<@s>$;
    } else {
        bwe_min_x<@s> = $bwe_pos2_x<@s>$;
        bwe_max_x<@s> = $bwe_pos1_x<@s>$;
    }
    // Y bounds
    if $bwe_pos1_y<@s>$ <= $bwe_pos2_y<@s>$ {
        bwe_min_y<@s> = $bwe_pos1_y<@s>$;
        bwe_max_y<@s> = $bwe_pos2_y<@s>$;
    } else {
        bwe_min_y<@s> = $bwe_pos2_y<@s>$;
        bwe_max_y<@s> = $bwe_pos1_y<@s>$;
    }
    // Z bounds
    if $bwe_pos1_z<@s>$ <= $bwe_pos2_z<@s>$ {
        bwe_min_z<@s> = $bwe_pos1_z<@s>$;
        bwe_max_z<@s> = $bwe_pos2_z<@s>$;
    } else {
        bwe_min_z<@s> = $bwe_pos2_z<@s>$;
        bwe_max_z<@s> = $bwe_pos1_z<@s>$;
    }

    // Dimensions (inclusive)
    $!raw
    scoreboard players operation @s bwe_dim_x = @s bwe_max_x
    scoreboard players operation @s bwe_dim_x -= @s bwe_min_x
    scoreboard players add @s bwe_dim_x 1

    scoreboard players operation @s bwe_dim_y = @s bwe_max_y
    scoreboard players operation @s bwe_dim_y -= @s bwe_min_y
    scoreboard players add @s bwe_dim_y 1

    scoreboard players operation @s bwe_dim_z = @s bwe_max_z
    scoreboard players operation @s bwe_dim_z -= @s bwe_min_z
    scoreboard players add @s bwe_dim_z 1
    raw!$

    // Volume
    $!raw
    scoreboard players operation @s _temp = @s bwe_dim_x
    scoreboard players operation @s _temp *= @s bwe_dim_y
    scoreboard players operation @s bwe_volume = @s _temp
    scoreboard players operation @s bwe_volume *= @s bwe_dim_z
    raw!$
}

function betterworldedit:info {
    exec betterworldedit:_compute_bounds;
    $!raw
    tellraw @s [{"text":"Selection Info","bold":true,"color":"aqua"}]
    tellraw @s [{"text":"Pos1:","color":"gray"},{"text":" (","color":"dark_gray"},{"score":{"name":"@s","objective":"bwe_pos1_x"},"color":"aqua"},{"text":", ","color":"dark_gray"},{"score":{"name":"@s","objective":"bwe_pos1_y"},"color":"aqua"},{"text":", ","color":"dark_gray"},{"score":{"name":"@s","objective":"bwe_pos1_z"},"color":"aqua"},{"text":")","color":"dark_gray"}]
    tellraw @s [{"text":"Pos2:","color":"gray"},{"text":" (","color":"dark_gray"},{"score":{"name":"@s","objective":"bwe_pos2_x"},"color":"aqua"},{"text":", ","color":"dark_gray"},{"score":{"name":"@s","objective":"bwe_pos2_y"},"color":"aqua"},{"text":", ","color":"dark_gray"},{"score":{"name":"@s","objective":"bwe_pos2_z"},"color":"aqua"},{"text":")","color":"dark_gray"}]
    tellraw @s [{"text":"Bounds:","color":"gray"},{"text":" min ","color":"dark_gray"},{"text":"(","color":"dark_gray"},{"score":{"name":"@s","objective":"bwe_min_x"},"color":"aqua"},{"text":", ","color":"dark_gray"},{"score":{"name":"@s","objective":"bwe_min_y"},"color":"aqua"},{"text":", ","color":"dark_gray"},{"score":{"name":"@s","objective":"bwe_min_z"},"color":"aqua"},{"text":") ","color":"dark_gray"},{"text":"max ","color":"dark_gray"},{"text":"(","color":"dark_gray"},{"score":{"name":"@s","objective":"bwe_max_x"},"color":"aqua"},{"text":", ","color":"dark_gray"},{"score":{"name":"@s","objective":"bwe_max_y"},"color":"aqua"},{"text":", ","color":"dark_gray"},{"score":{"name":"@s","objective":"bwe_max_z"},"color":"aqua"},{"text":")","color":"dark_gray"}]
    tellraw @s [{"text":"Dims:","color":"gray"},{"score":{"name":"@s","objective":"bwe_dim_x"},"color":"aqua"},{"text":" x ","color":"dark_gray"},{"score":{"name":"@s","objective":"bwe_dim_y"},"color":"aqua"},{"text":" x ","color":"dark_gray"},{"score":{"name":"@s","objective":"bwe_dim_z"},"color":"aqua"},{"text":" = ","color":"dark_gray"},{"score":{"name":"@s","objective":"bwe_volume"},"color":"yellow"}]
    raw!$
}

// =============================
// Ensure & Tick
// =============================

function betterworldedit:_ensure_scores_for_player {
    $!raw
    # Flags & positions
    scoreboard players add @s bwe_pos1_set 0
    scoreboard players add @s bwe_pos2_set 0
    scoreboard players add @s bwe_pos1_x 0
    scoreboard players add @s bwe_pos1_y 0
    scoreboard players add @s bwe_pos1_z 0
    scoreboard players add @s bwe_pos2_x 0
    scoreboard players add @s bwe_pos2_y 0
    scoreboard players add @s bwe_pos2_z 0

    # Derived
    scoreboard players add @s bwe_min_x 0
    scoreboard players add @s bwe_min_y 0
    scoreboard players add @s bwe_min_z 0
    scoreboard players add @s bwe_max_x 0
    scoreboard players add @s bwe_max_y 0
    scoreboard players add @s bwe_max_z 0
    scoreboard players add @s bwe_dim_x 0
    scoreboard players add @s bwe_dim_y 0
    scoreboard players add @s bwe_dim_z 0
    scoreboard players add @s bwe_volume 0

    # Config (mirror from global at fill start)
    scoreboard players add @s bwe_max_fill 0
    execute store result score @s bwe_max_fill run scoreboard players get @e[type=armor_stand,tag=bwe_global_config,limit=1] bwe_max_fill

    # Scratch
    scoreboard players add @s _slice_h 0
    scoreboard players add @s _slices 0
    scoreboard players add @s _y_start 0
    scoreboard players add @s _y_end 0
    scoreboard players add @s _xs 0
    scoreboard players add @s _xe 0
    scoreboard players add @s _zs 0
    scoreboard players add @s _ze 0
    scoreboard players add @s _tile_x 0
    scoreboard players add @s _tile_z 0
    scoreboard players add @s _temp 0
    scoreboard players add @s _ix 0
    scoreboard players add @s _iy 0
    scoreboard players add @s _iz 0
    scoreboard players add @s _fill_active 0
    scoreboard players add @s _fill_desc 0

    scoreboard players add @s _op_mode 0

    scoreboard players add @s _fi 0
    scoreboard players add @s _u_idx 0
    scoreboard players add @s _v_idx 0
    scoreboard players add @s _tile_u 0
    scoreboard players add @s _tile_v 0
    scoreboard players add @s _us 0
    scoreboard players add @s _ue 0
    scoreboard players add @s _vs 0
    scoreboard players add @s _ve 0

    scoreboard players add @s _ej 0
    scoreboard players add @s _seg_idx 0

    scoreboard players add @s _mask_mode 0

    # Selector stats
    scoreboard players add @s bwe_stat_selector 0
    scoreboard players add @s bwe_stat_selector_2 0
    scoreboard players add @s bwe_stat_prev_1 0
    scoreboard players add @s bwe_stat_prev_2 0
    raw!$
}

function betterworldedit:main_tick {
    exec betterworldedit:update_selector<@a>;
    exec betterworldedit:process_fill_tick<@a>;
}

on_tick betterworldedit:main_tick;

// =============================
// Chunked fill + Masked subfill helpers
// =============================

// Macros for different vanilla fill modes
function betterworldedit:_fill_slice_all {
    $fill $(x1) $(y1) $(z1) $(x2) $(y2) $(z2) $(block)
}
function betterworldedit:_fill_slice_keep {
    $fill $(x1) $(y1) $(z1) $(x2) $(y2) $(z2) $(block) keep
}
function betterworldedit:_fill_slice_destroy {
    $fill $(x1) $(y1) $(z1) $(x2) $(y2) $(z2) $(block) destroy
}
function betterworldedit:_fill_slice_replace {
    $fill $(x1) $(y1) $(z1) $(x2) $(y2) $(z2) $(block) replace $(filter)
}

// Deprecated legacy macro (kept for reference)
function betterworldedit:_fill_slice_macro {
    $fill $(x1) $(y1) $(z1) $(x2) $(y2) $(z2) $(block)
}

function betterworldedit:_prepare_fill_ctx {
    $!raw
    # Reset compound
    data remove storage betterworldedit:ctx fill
    data modify storage betterworldedit:ctx fill set value {}
    # Coords from scoreboard
    execute store result storage betterworldedit:ctx fill.x1 int 1 run scoreboard players get @s _xs
    execute store result storage betterworldedit:ctx fill.y1 int 1 run scoreboard players get @s _y_start
    execute store result storage betterworldedit:ctx fill.z1 int 1 run scoreboard players get @s _zs
    execute store result storage betterworldedit:ctx fill.x2 int 1 run scoreboard players get @s _xe
    execute store result storage betterworldedit:ctx fill.y2 int 1 run scoreboard players get @s _y_end
    execute store result storage betterworldedit:ctx fill.z2 int 1 run scoreboard players get @s _ze
    # Block id from request
    data modify storage betterworldedit:ctx fill.block set from storage betterworldedit:ctx req.block
    # Optional mask filter string for replace-mode
    execute if data storage betterworldedit:ctx req{filter:""} run data remove storage betterworldedit:ctx req.filter
    execute if data storage betterworldedit:ctx req.filter run data modify storage betterworldedit:ctx fill.filter set from storage betterworldedit:ctx req.filter
    raw!$
}

// Runtime dispatch to the proper vanilla fill variant based on _mask_mode
function betterworldedit:_do_subfill {
    exec betterworldedit:_prepare_fill_ctx;
    if $_mask_mode<@s>$ == 0 {
        exec betterworldedit:_fill_slice_all with storage betterworldedit:ctx fill;
    } else {
        if $_mask_mode<@s>$ == 1 {
            exec betterworldedit:_fill_slice_keep with storage betterworldedit:ctx fill;
        } else {
            if $_mask_mode<@s>$ == 2 {
                exec betterworldedit:_fill_slice_destroy with storage betterworldedit:ctx fill;
            } else {
                exec betterworldedit:_fill_slice_replace with storage betterworldedit:ctx fill;
            }
        }
    }
}

// Parse mask from storage req.mask{mode,filter} to per-player scoreboard + req.filter string
function betterworldedit:_parse_mask {
    $!raw
    # default
    scoreboard players set @s _mask_mode 0

    # mode: keep
    execute if data storage betterworldedit:ctx req{mask:{mode:"keep"}} run scoreboard players set @s _mask_mode 1
    # mode: destroy
    execute if data storage betterworldedit:ctx req{mask:{mode:"destroy"}} run scoreboard players set @s _mask_mode 2
    # mode: replace (requires filter)
    execute if data storage betterworldedit:ctx req{mask:{mode:"replace"}} run scoreboard players set @s _mask_mode 3

    # copy filter if present (string like "minecraft:stone" or "#minecraft:leaves")
    execute if data storage betterworldedit:ctx req.mask.filter run data modify storage betterworldedit:ctx req.filter set from storage betterworldedit:ctx req.mask.filter
    raw!$
}

// Unified fill function that handles all three modes (solid, hollow, outline)
function betterworldedit:fill_block_unified {
    // Ensure global config and player score entries only when starting a fill
    exec betterworldedit:_ensure_global_config;
    exec betterworldedit:_ensure_scores_for_player;
    exec betterworldedit:_compute_bounds;
    $!raw
    execute unless data storage betterworldedit:ctx req.block run data modify storage betterworldedit:ctx req.block set value "minecraft:stone"
    raw!$
    if $bwe_volume<@s>$ == 0 {
        $!raw
        tellraw @s [{"text":"No selection set!","color":"red"},{"text":" Use ","color":"gray"},{"text":"pos1","color":"gold"},{"text":"/","color":"dark_gray"},{"text":"pos2","color":"gold"},{"text":" first.","color":"gray"}]
        raw!$
    } else {
        // Different messaging for different modes
        if $_op_mode<@s>$ == 1 {
            $!raw
            tellraw @s [{"text":"Filling selection with "},{"storage":"betterworldedit:ctx","nbt":"req.block"},{"text":" (mask:"},{"score":{"name":"@s","objective":"_mask_mode"}},{"text":") ... ("},{"score":{"name":"@s","objective":"bwe_dim_x"}},{"text":"x"},{"score":{"name":"@s","objective":"bwe_dim_y"}},{"text":"x"},{"score":{"name":"@s","objective":"bwe_dim_z"}},{"text":" = "},{"score":{"name":"@s","objective":"bwe_volume"}},{"text":") max per op="},{"score":{"name":"@s","objective":"bwe_max_fill"}},{"text":")"}]
            raw!$
        } else {
            if $_op_mode<@s>$ == 2 {
                $!raw
                tellraw @s [{"text":"Hollow filling selection with "},{"storage":"betterworldedit:ctx","nbt":"req.block"},{"text":" (mask:"},{"score":{"name":"@s","objective":"_mask_mode"}},{"text":") ... ("},{"score":{"name":"@s","objective":"bwe_dim_x"}},{"text":"x"},{"score":{"name":"@s","objective":"bwe_dim_y"}},{"text":"x"},{"score":{"name":"@s","objective":"bwe_dim_z"}},{"text":" = "},{"score":{"name":"@s","objective":"bwe_volume"}},{"text":") max per op="},{"score":{"name":"@s","objective":"bwe_max_fill"}},{"text":")"}]
                raw!$
            } else {
                $!raw
                tellraw @s [{"text":"Outline filling selection with "},{"storage":"betterworldedit:ctx","nbt":"req.block"},{"text":" (mask:"},{"score":{"name":"@s","objective":"_mask_mode"}},{"text":") ... ("},{"score":{"name":"@s","objective":"bwe_dim_x"}},{"text":"x"},{"score":{"name":"@s","objective":"bwe_dim_y"}},{"text":"x"},{"score":{"name":"@s","objective":"bwe_dim_z"}},{"text":" = "},{"score":{"name":"@s","objective":"bwe_volume"}},{"text":") max per op="},{"score":{"name":"@s","objective":"bwe_max_fill"}},{"text":")"}]
                raw!$
            }
        }

        // Determine fill direction for solid fills based on global configuration
        exec betterworldedit:_determine_fill_direction;

        // Initialize mode-specific variables
        if $_op_mode<@s>$ == 2 {
            // Hollow mode initialization
            _fi<@s> = 0;
            _u_idx<@s> = 0;
            _v_idx<@s> = 0;
        } else {
            if $_op_mode<@s>$ == 3 {
                // Outline mode initialization  
                _ej<@s> = 0;
                _seg_idx<@s> = 0;
            }
        }

        // Check if single fill is possible (solid fills only)
        if $_op_mode<@s>$ == 1 {
            // Single fill if within limit (overflow-safe check via chained divisions)
            _temp<@s> = $bwe_max_fill<@s>$;
            _temp<@s> = $_temp<@s>$ / $bwe_dim_x<@s>$;
            _temp<@s> = $_temp<@s>$ / $bwe_dim_y<@s>$;
            if $_temp<@s>$ >= $bwe_dim_z<@s>$ {
                if $_fill_desc<@s>$ == 0 {
                    _y_start<@s> = $bwe_min_y<@s>$;
                    _y_end<@s> = $bwe_max_y<@s>$;
                } else {
                    _y_start<@s> = $bwe_max_y<@s>$;
                    _y_end<@s> = $bwe_min_y<@s>$;
                }
                $!raw
                scoreboard players operation @s _xs = @s bwe_min_x
                scoreboard players operation @s _xe = @s bwe_max_x
                scoreboard players operation @s _zs = @s bwe_min_z
                scoreboard players operation @s _ze = @s bwe_max_z
                raw!$
                exec betterworldedit:_do_subfill;
                $!raw
                tellraw @s [{"text":"Done","color":"green"},{"text":" (single fill)","color":"gray"}]
                raw!$
            } else {
                // Solid fill needs chunked processing
                _slice_h<@s> = $bwe_max_fill<@s>$;
                _slice_h<@s> = $_slice_h<@s>$ / $bwe_dim_x<@s>$;
                _slice_h<@s> = $_slice_h<@s>$ / $bwe_dim_z<@s>$;
                if $_slice_h<@s>$ < 1 { _slice_h<@s> = 1; }
                if $_slice_h<@s>$ > $bwe_dim_y<@s>$ { _slice_h<@s> = $bwe_dim_y<@s>$; }

                // area_limit per slice in _temp
                _temp<@s> = $bwe_max_fill<@s>$ / $_slice_h<@s>$;
                if $_temp<@s>$ < 1 { _temp<@s> = 1; }

                // tile_x = clamp(floor(area_limit / dim_z), 1..dim_x)
                _tile_x<@s> = $_temp<@s>$ / $bwe_dim_z<@s>$;
                if $_tile_x<@s>$ < 1 { _tile_x<@s> = 1; }
                if $_tile_x<@s>$ > $bwe_dim_x<@s>$ { _tile_x<@s> = $bwe_dim_x<@s>$; }

                // tile_z = clamp(floor(area_limit / tile_x), 1..dim_z)
                _tile_z<@s> = $_temp<@s>$ / $_tile_x<@s>$;
                if $_tile_z<@s>$ < 1 { _tile_z<@s> = 1; }
                if $_tile_z<@s>$ > $bwe_dim_z<@s>$ { _tile_z<@s> = $bwe_dim_z<@s>$; }

                // Initialize indices and activate the per-tick processor
                _ix<@s> = 0;
                _iy<@s> = 0;
                _iz<@s> = 0;
                _slices<@s> = 0;
                _fill_active<@s> = 1;
                $!raw
                tellraw @s [{"text":"Started chunked fill","color":"green"},{"text":"; ","color":"dark_gray"},{"text":"running across ticks...","color":"gray"}]
                raw!$
            }
        } else {
            // Hollow and outline modes always use chunked processing
            // Compute tile sizes for hollow and outline modes
            if $_op_mode<@s>$ == 2 {
                // Hollow mode: optimize for 2D face tiling
                // For faces parallel to XZ plane: tile_u based on X, tile_v based on Z
                _tile_x<@s> = $bwe_max_fill<@s>$ / $bwe_dim_z<@s>$;  // U tiles for XZ faces
                if $_tile_x<@s>$ < 1 { _tile_x<@s> = 1; }
                if $_tile_x<@s>$ > $bwe_dim_x<@s>$ { _tile_x<@s> = $bwe_dim_x<@s>$; }
                
                _tile_z<@s> = $bwe_max_fill<@s>$ / $_tile_x<@s>$;    // V tiles for XZ faces
                if $_tile_z<@s>$ < 1 { _tile_z<@s> = 1; }
                if $_tile_z<@s>$ > $bwe_dim_z<@s>$ { _tile_z<@s> = $bwe_dim_z<@s>$; }
                
                _slice_h<@s> = 1;  // Single layer at a time for faces
            } else {
                // Outline mode: optimize for edge segments
                // Use smaller chunks for better distribution along edges
                _temp<@s> = $bwe_max_fill<@s>$ / 4;  // Quarter max_fill for edge segments
                if $_temp<@s>$ < 1 { _temp<@s> = 1; }
                
                _tile_x<@s> = $_temp<@s>$;
                _tile_z<@s> = $_temp<@s>$;
                _slice_h<@s> = $_temp<@s>$;
                
                // Clamp to dimension limits
                if $_tile_x<@s>$ > $bwe_dim_x<@s>$ { _tile_x<@s> = $bwe_dim_x<@s>$; }
                if $_tile_z<@s>$ > $bwe_dim_z<@s>$ { _tile_z<@s> = $bwe_dim_z<@s>$; }
                if $_slice_h<@s>$ > $bwe_dim_y<@s>$ { _slice_h<@s> = $bwe_dim_y<@s>$; }
            }

            // Initialize indices and activate the per-tick processor for hollow/outline
            _ix<@s> = 0;
            _iy<@s> = 0;
            _iz<@s> = 0;
            _slices<@s> = 0;
            _fill_active<@s> = 1;
            $!raw
            tellraw @s [{"text":"Started chunked fill","color":"green"},{"text":"; ","color":"dark_gray"},{"text":"running across ticks...","color":"gray"}]
            raw!$
        }
    }
}

// Legacy function for backward compatibility
function betterworldedit:fill_block {
    _op_mode<@s> = 1;
    exec betterworldedit:fill_block_unified;
}

function betterworldedit:process_fill_tick {
    // If a chunked operation is active, process one sub-fill per tick per player
    if $_fill_active<@s>$ == 1 {

        // ============ MODE 1: SOLID (existing logic; fixed control flow) ============
        if $_op_mode<@s>$ == 1 {

            // Compute layer start based on direction
            if $_fill_desc<@s>$ == 0 {
                _y_start<@s> = $bwe_min_y<@s>$ + ($_iy<@s>$ * $_slice_h<@s>$);
            } else {
                _y_start<@s> = $bwe_max_y<@s>$ - ($_iy<@s>$ * $_slice_h<@s>$);
            }

            // Finish or continue (two branches; no stray else)
            if $_fill_desc<@s>$ == 0 {
                if $_y_start<@s>$ > $bwe_max_y<@s>$ {
                    _fill_active<@s> = 0;
                    $!raw tellraw @s [{"text":"Done ","color":"green"},{"text":"(","color":"dark_gray"},{"score":{"name":"@s","objective":"_slices"},"color":"yellow"},{"text":" sub-fills)","color":"gray"}] raw!$
                } else {
                    // Compute row/col starts
                    _xs<@s> = $bwe_min_x<@s>$ + ($_ix<@s>$ * $_tile_x<@s>$);
                    _zs<@s> = $bwe_min_z<@s>$ + ($_iz<@s>$ * $_tile_z<@s>$);

                    // Wrap Z -> X -> Y
                    if $_zs<@s>$ > $bwe_max_z<@s>$ {
                        _iz<@s> = 0;
                        _ix<@s> = $_ix<@s>$ + 1;
                        _zs<@s> = $bwe_min_z<@s>$ + ($_iz<@s>$ * $_tile_z<@s>$);
                        _xs<@s> = $bwe_min_x<@s>$ + ($_ix<@s>$ * $_tile_x<@s>$);
                    }

                    if $_xs<@s>$ > $bwe_max_x<@s>$ {
                        _ix<@s> = 0;
                        _iy<@s> = $_iy<@s>$ + 1;
                        _xs<@s> = $bwe_min_x<@s>$ + ($_ix<@s>$ * $_tile_x<@s>$);
                        if $_fill_desc<@s>$ == 0 {
                            _y_start<@s> = $bwe_min_y<@s>$ + ($_iy<@s>$ * $_slice_h<@s>$);
                        } else {
                            _y_start<@s> = $bwe_max_y<@s>$ - ($_iy<@s>$ * $_slice_h<@s>$);
                        }
                    }

                    if $_fill_active<@s>$ == 1 {
                        // Compute ends + clamps (respect direction)
                        if $_fill_desc<@s>$ == 0 {
                            _y_end<@s> = $_y_start<@s>$ + $_slice_h<@s>$ - 1;
                            if $_y_end<@s>$ > $bwe_max_y<@s>$ { _y_end<@s> = $bwe_max_y<@s>$; }
                        } else {
                            _y_end<@s> = $_y_start<@s>$ - $_slice_h<@s>$ + 1;
                            if $_y_end<@s>$ < $bwe_min_y<@s>$ { _y_end<@s> = $bwe_min_y<@s>$; }
                            if $_y_start<@s>$ > $_y_end<@s>$ {
                                _temp<@s> = $_y_start<@s>$;
                                _y_start<@s> = $_y_end<@s>$;
                                _y_end<@s> = $_temp<@s>$;
                            }
                        }

                        _xe<@s> = $_xs<@s>$ + $_tile_x<@s>$ - 1;
                        if $_xe<@s>$ > $bwe_max_x<@s>$ { _xe<@s> = $bwe_max_x<@s>$; }

                        _ze<@s> = $_zs<@s>$ + $_tile_z<@s>$ - 1;
                        if $_ze<@s>$ > $bwe_max_z<@s>$ { _ze<@s> = $bwe_max_z<@s>$; }

                        // Sub-fill with mask
                        exec betterworldedit:_do_subfill;

                        _slices<@s> = $_slices<@s>$ + 1;
                        _iz<@s> = $_iz<@s>$ + 1;
                    }
                }
            } else {
                if $_y_start<@s>$ < $bwe_min_y<@s>$ {
                    _fill_active<@s> = 0;
                    $!raw tellraw @s [{"text":"Done ","color":"green"},{"text":"(","color":"dark_gray"},{"score":{"name":"@s","objective":"_slices"},"color":"yellow"},{"text":" sub-fills)","color":"gray"}] raw!$
                } else {
                    // Compute row/col starts (desc)
                    _xs<@s> = $bwe_min_x<@s>$ + ($_ix<@s>$ * $_tile_x<@s>$);
                    _zs<@s> = $bwe_min_z<@s>$ + ($_iz<@s>$ * $_tile_z<@s>$);

                    if $_zs<@s>$ > $bwe_max_z<@s>$ {
                        _iz<@s> = 0;
                        _ix<@s> = $_ix<@s>$ + 1;
                        _zs<@s> = $bwe_min_z<@s>$ + ($_iz<@s>$ * $_tile_z<@s>$);
                        _xs<@s> = $bwe_min_x<@s>$ + ($_ix<@s>$ * $_tile_x<@s>$);
                    }

                    if $_xs<@s>$ > $bwe_max_x<@s>$ {
                        _ix<@s> = 0;
                        _iy<@s> = $_iy<@s>$ + 1;
                        _xs<@s> = $bwe_min_x<@s>$ + ($_ix<@s>$ * $_tile_x<@s>$);
                        if $_fill_desc<@s>$ == 0 {
                            _y_start<@s> = $bwe_min_y<@s>$ + ($_iy<@s>$ * $_slice_h<@s>$);
                        } else {
                            _y_start<@s> = $bwe_max_y<@s>$ - ($_iy<@s>$ * $_slice_h<@s>$);
                        }
                    }

                    if $_fill_active<@s>$ == 1 {
                        if $_fill_desc<@s>$ == 0 {
                            _y_end<@s> = $_y_start<@s>$ + $_slice_h<@s>$ - 1;
                            if $_y_end<@s>$ > $bwe_max_y<@s>$ { _y_end<@s> = $bwe_max_y<@s>$; }
                        } else {
                            _y_end<@s> = $_y_start<@s>$ - $_slice_h<@s>$ + 1;
                            if $_y_end<@s>$ < $bwe_min_y<@s>$ { _y_end<@s> = $bwe_min_y<@s>$; }
                            if $_y_start<@s>$ > $_y_end<@s>$ {
                                _temp<@s> = $_y_start<@s>$;
                                _y_start<@s> = $_y_end<@s>$;
                                _y_end<@s> = $_temp<@s>$;
                            }
                        }

                        _xe<@s> = $_xs<@s>$ + $_tile_x<@s>$ - 1;
                        if $_xe<@s>$ > $bwe_max_x<@s>$ { _xe<@s> = $bwe_max_x<@s>$; }

                        _ze<@s> = $_zs<@s>$ + $_tile_z<@s>$ - 1;
                        if $_ze<@s>$ > $bwe_max_z<@s>$ { _ze<@s> = $bwe_max_z<@s>$; }

                        exec betterworldedit:_do_subfill;

                        _slices<@s> = $_slices<@s>$ + 1;
                        _iz<@s> = $_iz<@s>$ + 1;
                    }
                }
            }
        }

        // ============ MODE 2: HOLLOW (6 faces, 2D tiling; no logical operators) ============
        else {
            if $_op_mode<@s>$ == 2 {

                // Face 0: bottom Ymin (u=X, v=Z, y=bwe_min_y)
                if $_fi<@s>$ == 0 {
                    // Use pre-calculated tile sizes from initialization
                    _tile_u<@s> = $_tile_x<@s>$;  // U dimension maps to X
                    _tile_v<@s> = $_tile_z<@s>$;  // V dimension maps to Z

                    _us<@s> = $bwe_min_x<@s>$ + ($_u_idx<@s>$ * $_tile_u<@s>$);
                    _vs<@s> = $bwe_min_z<@s>$ + ($_v_idx<@s>$ * $_tile_v<@s>$);

                    if $_vs<@s>$ > $bwe_max_z<@s>$ {
                        _v_idx<@s> = 0;
                        _u_idx<@s> = $_u_idx<@s>$ + 1;
                        _us<@s> = $bwe_min_x<@s>$ + ($_u_idx<@s>$ * $_tile_u<@s>$);
                        _vs<@s> = $bwe_min_z<@s>$ + ($_v_idx<@s>$ * $_tile_v<@s>$);
                    }

                    if $_us<@s>$ > $bwe_max_x<@s>$ {
                        _u_idx<@s> = 0;
                        _v_idx<@s> = 0;
                        _fi<@s> = 1;
                    } else {
                        _ue<@s> = $_us<@s>$ + $_tile_u<@s>$ - 1;
                        if $_ue<@s>$ > $bwe_max_x<@s>$ { _ue<@s> = $bwe_max_x<@s>$; }
                        _ve<@s> = $_vs<@s>$ + $_tile_v<@s>$ - 1;
                        if $_ve<@s>$ > $bwe_max_z<@s>$ { _ve<@s> = $bwe_max_z<@s>$; }

                        _xs<@s> = $_us<@s>$; _xe<@s> = $_ue<@s>$;
                        _zs<@s> = $_vs<@s>$; _ze<@s> = $_ve<@s>$;
                        _y_start<@s> = $bwe_min_y<@s>$; _y_end<@s> = $bwe_min_y<@s>$;

                        exec betterworldedit:_do_subfill;

                        _slices<@s> = $_slices<@s>$ + 1;
                        _v_idx<@s> = $_v_idx<@s>$ + 1;
                    }
                }
                else {
                    // Face 1: top Ymax (u=X, v=Z, y=bwe_max_y)
                    if $_fi<@s>$ == 1 {
                        // Use pre-calculated tile sizes from initialization
                        _tile_u<@s> = $_tile_x<@s>$;  // U dimension maps to X
                        _tile_v<@s> = $_tile_z<@s>$;  // V dimension maps to Z

                        _us<@s> = $bwe_min_x<@s>$ + ($_u_idx<@s>$ * $_tile_u<@s>$);
                        _vs<@s> = $bwe_min_z<@s>$ + ($_v_idx<@s>$ * $_tile_v<@s>$);

                        if $_vs<@s>$ > $bwe_max_z<@s>$ {
                            _v_idx<@s> = 0;
                            _u_idx<@s> = $_u_idx<@s>$ + 1;
                            _us<@s> = $bwe_min_x<@s>$ + ($_u_idx<@s>$ * $_tile_u<@s>$);
                            _vs<@s> = $bwe_min_z<@s>$ + ($_v_idx<@s>$ * $_tile_v<@s>$);
                        }

                        if $_us<@s>$ > $bwe_max_x<@s>$ {
                            _u_idx<@s> = 0;
                            _v_idx<@s> = 0;
                            _fi<@s> = 2;
                        } else {
                            _ue<@s> = $_us<@s>$ + $_tile_u<@s>$ - 1;
                            if $_ue<@s>$ > $bwe_max_x<@s>$ { _ue<@s> = $bwe_max_x<@s>$; }
                            _ve<@s> = $_vs<@s>$ + $_tile_v<@s>$ - 1;
                            if $_ve<@s>$ > $bwe_max_z<@s>$ { _ve<@s> = $bwe_max_z<@s>$; }

                            _xs<@s> = $_us<@s>$; _xe<@s> = $_ue<@s>$;
                            _zs<@s> = $_vs<@s>$; _ze<@s> = $_ve<@s>$;
                            _y_start<@s> = $bwe_max_y<@s>$; _y_end<@s> = $bwe_max_y<@s>$;

                            exec betterworldedit:_do_subfill;

                            _slices<@s> = $_slices<@s>$ + 1;
                            _v_idx<@s> = $_v_idx<@s>$ + 1;
                        }
                    }
                    else {
                        // Face 2: north Zmin (u=X, v=Y, z=bwe_min_z)
                        if $_fi<@s>$ == 2 {
                            // Use pre-calculated tile sizes from initialization
                            _tile_u<@s> = $_tile_x<@s>$;  // U dimension maps to X
                            _tile_v<@s> = $_slice_h<@s>$; // V dimension maps to Y (use slice_h)

                            _us<@s> = $bwe_min_x<@s>$ + ($_u_idx<@s>$ * $_tile_u<@s>$);
                            _vs<@s> = $bwe_min_y<@s>$ + ($_v_idx<@s>$ * $_tile_v<@s>$);

                            if $_vs<@s>$ > $bwe_max_y<@s>$ {
                                _v_idx<@s> = 0;
                                _u_idx<@s> = $_u_idx<@s>$ + 1;
                                _us<@s> = $bwe_min_x<@s>$ + ($_u_idx<@s>$ * $_tile_u<@s>$);
                                _vs<@s> = $bwe_min_y<@s>$ + ($_v_idx<@s>$ * $_tile_v<@s>$);
                            }

                            if $_us<@s>$ > $bwe_max_x<@s>$ {
                                _u_idx<@s> = 0;
                                _v_idx<@s> = 0;
                                _fi<@s> = 3;
                            } else {
                                _ue<@s> = $_us<@s>$ + $_tile_u<@s>$ - 1;
                                if $_ue<@s>$ > $bwe_max_x<@s>$ { _ue<@s> = $bwe_max_x<@s>$; }
                                _ve<@s> = $_vs<@s>$ + $_tile_v<@s>$ - 1;
                                if $_ve<@s>$ > $bwe_max_y<@s>$ { _ve<@s> = $bwe_max_y<@s>$; }

                                _xs<@s> = $_us<@s>$; _xe<@s> = $_ue<@s>$;
                                _y_start<@s> = $_vs<@s>$; _y_end<@s> = $_ve<@s>$;
                                _zs<@s> = $bwe_min_z<@s>$; _ze<@s> = $bwe_min_z<@s>$;

                                exec betterworldedit:_do_subfill;

                                _slices<@s> = $_slices<@s>$ + 1;
                                _v_idx<@s> = $_v_idx<@s>$ + 1;
                            }
                        }
                        else {
                            // Face 3: south Zmax (u=X, v=Y, z=bwe_max_z)
                            if $_fi<@s>$ == 3 {
                                // Use pre-calculated tile sizes from initialization
                                _tile_u<@s> = $_tile_x<@s>$;  // U dimension maps to X
                                _tile_v<@s> = $_slice_h<@s>$; // V dimension maps to Y (use slice_h)

                                _us<@s> = $bwe_min_x<@s>$ + ($_u_idx<@s>$ * $_tile_u<@s>$);
                                _vs<@s> = $bwe_min_y<@s>$ + ($_v_idx<@s>$ * $_tile_v<@s>$);

                                if $_vs<@s>$ > $bwe_max_y<@s>$ {
                                    _v_idx<@s> = 0;
                                    _u_idx<@s> = $_u_idx<@s>$ + 1;
                                    _us<@s> = $bwe_min_x<@s>$ + ($_u_idx<@s>$ * $_tile_u<@s>$);
                                    _vs<@s> = $bwe_min_y<@s>$ + ($_v_idx<@s>$ * $_tile_v<@s>$);
                                }

                                if $_us<@s>$ > $bwe_max_x<@s>$ {
                                    _u_idx<@s> = 0;
                                    _v_idx<@s> = 0;
                                    _fi<@s> = 4;
                                } else {
                                    _ue<@s> = $_us<@s>$ + $_tile_u<@s>$ - 1;
                                    if $_ue<@s>$ > $bwe_max_x<@s>$ { _ue<@s> = $bwe_max_x<@s>$; }
                                    _ve<@s> = $_vs<@s>$ + $_tile_v<@s>$ - 1;
                                    if $_ve<@s>$ > $bwe_max_y<@s>$ { _ve<@s> = $bwe_max_y<@s>$; }

                                    _xs<@s> = $_us<@s>$; _xe<@s> = $_ue<@s>$;
                                    _y_start<@s> = $_vs<@s>$; _y_end<@s> = $_ve<@s>$;
                                    _zs<@s> = $bwe_max_z<@s>$; _ze<@s> = $bwe_max_z<@s>$;

                                    exec betterworldedit:_do_subfill;

                                    _slices<@s> = $_slices<@s>$ + 1;
                                    _v_idx<@s> = $_v_idx<@s>$ + 1;
                                }
                            }
                            else {
                                // Face 4: west Xmin (u=Z, v=Y, x=bwe_min_x)
                                if $_fi<@s>$ == 4 {
                                    // Use pre-calculated tile sizes from initialization
                                    _tile_u<@s> = $_tile_z<@s>$;  // U dimension maps to Z
                                    _tile_v<@s> = $_slice_h<@s>$; // V dimension maps to Y (use slice_h)

                                    _us<@s> = $bwe_min_z<@s>$ + ($_u_idx<@s>$ * $_tile_u<@s>$);
                                    _vs<@s> = $bwe_min_y<@s>$ + ($_v_idx<@s>$ * $_tile_v<@s>$);

                                    if $_vs<@s>$ > $bwe_max_y<@s>$ {
                                        _v_idx<@s> = 0;
                                        _u_idx<@s> = $_u_idx<@s>$ + 1;
                                        _us<@s> = $bwe_min_z<@s>$ + ($_u_idx<@s>$ * $_tile_u<@s>$);
                                        _vs<@s> = $bwe_min_y<@s>$ + ($_v_idx<@s>$ * $_tile_v<@s>$);
                                    }

                                    if $_us<@s>$ > $bwe_max_z<@s>$ {
                                        _u_idx<@s> = 0;
                                        _v_idx<@s> = 0;
                                        _fi<@s> = 5;
                                    } else {
                                        _ue<@s> = $_us<@s>$ + $_tile_u<@s>$ - 1;
                                        if $_ue<@s>$ > $bwe_max_z<@s>$ { _ue<@s> = $bwe_max_z<@s>$; }
                                        _ve<@s> = $_vs<@s>$ + $_tile_v<@s>$ - 1;
                                        if $_ve<@s>$ > $bwe_max_y<@s>$ { _ve<@s> = $bwe_max_y<@s>$; }

                                        _zs<@s> = $_us<@s>$; _ze<@s> = $_ue<@s>$;
                                        _y_start<@s> = $_vs<@s>$; _y_end<@s> = $_ve<@s>$;
                                        _xs<@s> = $bwe_min_x<@s>$; _xe<@s> = $bwe_min_x<@s>$;

                                        exec betterworldedit:_do_subfill;

                                        _slices<@s> = $_slices<@s>$ + 1;
                                        _v_idx<@s> = $_v_idx<@s>$ + 1;
                                    }
                                }
                                else {
                                    // Face 5: east Xmax (u=Z, v=Y, x=bwe_max_x)
                                    if $_fi<@s>$ == 5 {
                                        // Use pre-calculated tile sizes from initialization
                                        _tile_u<@s> = $_tile_z<@s>$;  // U dimension maps to Z
                                        _tile_v<@s> = $_slice_h<@s>$; // V dimension maps to Y (use slice_h)

                                        _us<@s> = $bwe_min_z<@s>$ + ($_u_idx<@s>$ * $_tile_u<@s>$);
                                        _vs<@s> = $bwe_min_y<@s>$ + ($_v_idx<@s>$ * $_tile_v<@s>$);

                                        if $_vs<@s>$ > $bwe_max_y<@s>$ {
                                            _v_idx<@s> = 0;
                                            _u_idx<@s> = $_u_idx<@s>$ + 1;
                                            _us<@s> = $bwe_min_z<@s>$ + ($_u_idx<@s>$ * $_tile_u<@s>$);
                                            _vs<@s> = $bwe_min_y<@s>$ + ($_v_idx<@s>$ * $_tile_v<@s>$);
                                        }

                                        if $_us<@s>$ > $bwe_max_z<@s>$ {
                                            _u_idx<@s> = 0;
                                            _v_idx<@s> = 0;
                                            _fi<@s> = 6; // sentinel beyond last face
                                        } else {
                                            _ue<@s> = $_us<@s>$ + $_tile_u<@s>$ - 1;
                                            if $_ue<@s>$ > $bwe_max_z<@s>$ { _ue<@s> = $bwe_max_z<@s>$; }
                                            _ve<@s> = $_vs<@s>$ + $_tile_v<@s>$ - 1;
                                            if $_ve<@s>$ > $bwe_max_y<@s>$ { _ve<@s> = $bwe_max_y<@s>$; }

                                            _zs<@s> = $_us<@s>$; _ze<@s> = $_ue<@s>$;
                                            _y_start<@s> = $_vs<@s>$; _y_end<@s> = $_ve<@s>$;
                                            _xs<@s> = $bwe_max_x<@s>$; _xe<@s> = $bwe_max_x<@s>$;

                                            exec betterworldedit:_do_subfill;

                                            _slices<@s> = $_slices<@s>$ + 1;
                                            _v_idx<@s> = $_v_idx<@s>$ + 1;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // Finish when all faces are done
                if $_fi<@s>$ > 5 {
                    _fill_active<@s> = 0;
                    $!raw tellraw @s [{"text":"Done (hollow faces) ","color":"green"},{"text":"(","color":"dark_gray"},{"score":{"name":"@s","objective":"_slices"},"color":"yellow"},{"text":" sub-fills)","color":"gray"}] raw!$
                }
            }
            else {
                // ============ MODE 3: OUTLINE (12 edges, segmented) ============
                if $_op_mode<@s>$ == 3 {

                    // X edges (0..3)
                    if $_ej<@s>$ <= 3 {
                        _ix<@s> = $_seg_idx<@s>$ * $_tile_x<@s>$; // offset along X using tile_x
                        if $_ix<@s>$ >= $bwe_dim_x<@s>$ {
                            _seg_idx<@s> = 0; _ej<@s> = $_ej<@s>$ + 1;
                        } else {
                            _slice_h<@s> = $_tile_x<@s>$;
                            if $_slice_h<@s>$ > $bwe_dim_x<@s>$ - $_ix<@s>$ { _slice_h<@s> = $bwe_dim_x<@s>$ - $_ix<@s>$; }

                            // 0: y=min,z=min | 1: y=min,z=max | 2: y=max,z=min | 3: y=max,z=max
                            if $_ej<@s>$ == 0 { _y_start<@s> = $bwe_min_y<@s>$; _y_end<@s> = $bwe_min_y<@s>$; _zs<@s> = $bwe_min_z<@s>$; _ze<@s> = $bwe_min_z<@s>$; }
                            else {
                                if $_ej<@s>$ == 1 { _y_start<@s> = $bwe_min_y<@s>$; _y_end<@s> = $bwe_min_y<@s>$; _zs<@s> = $bwe_max_z<@s>$; _ze<@s> = $bwe_max_z<@s>$; }
                                else {
                                    if $_ej<@s>$ == 2 { _y_start<@s> = $bwe_max_y<@s>$; _y_end<@s> = $bwe_max_y<@s>$; _zs<@s> = $bwe_min_z<@s>$; _ze<@s> = $bwe_min_z<@s>$; }
                                    else { _y_start<@s> = $bwe_max_y<@s>$; _y_end<@s> = $bwe_max_y<@s>$; _zs<@s> = $bwe_max_z<@s>$; _ze<@s> = $bwe_max_z<@s>$; }
                                }
                            }

                            _xs<@s> = $bwe_min_x<@s>$ + $_ix<@s>$;
                            _xe<@s> = $_xs<@s>$ + $_slice_h<@s>$ - 1;

                            exec betterworldedit:_do_subfill;

                            _slices<@s> = $_slices<@s>$ + 1;
                            _seg_idx<@s> = $_seg_idx<@s>$ + 1;
                        }
                    }
                    else {
                        // Z edges (4..7)
                        if $_ej<@s>$ <= 7 {
                            _iz<@s> = $_seg_idx<@s>$ * $_tile_z<@s>$; // offset along Z using tile_z
                            if $_iz<@s>$ >= $bwe_dim_z<@s>$ {
                                _seg_idx<@s> = 0; _ej<@s> = $_ej<@s>$ + 1;
                            } else {
                                _slice_h<@s> = $_tile_z<@s>$;
                                if $_slice_h<@s>$ > $bwe_dim_z<@s>$ - $_iz<@s>$ { _slice_h<@s> = $bwe_dim_z<@s>$ - $_iz<@s>$; }

                                // 4: y=min,x=min | 5: y=min,x=max | 6: y=max,x=min | 7: y=max,x=max
                                if $_ej<@s>$ == 4 { _y_start<@s> = $bwe_min_y<@s>$; _y_end<@s> = $bwe_min_y<@s>$; _xs<@s> = $bwe_min_x<@s>$; _xe<@s> = $bwe_min_x<@s>$; }
                                else {
                                    if $_ej<@s>$ == 5 { _y_start<@s> = $bwe_min_y<@s>$; _y_end<@s> = $bwe_min_y<@s>$; _xs<@s> = $bwe_max_x<@s>$; _xe<@s> = $bwe_max_x<@s>$; }
                                    else {
                                        if $_ej<@s>$ == 6 { _y_start<@s> = $bwe_max_y<@s>$; _y_end<@s> = $bwe_max_y<@s>$; _xs<@s> = $bwe_min_x<@s>$; _xe<@s> = $bwe_min_x<@s>$; }
                                        else { _y_start<@s> = $bwe_max_y<@s>$; _y_end<@s> = $bwe_max_y<@s>$; _xs<@s> = $bwe_max_x<@s>$; _xe<@s> = $bwe_max_x<@s>$; }
                                    }
                                }

                                _zs<@s> = $bwe_min_z<@s>$ + $_iz<@s>$;
                                _ze<@s> = $_zs<@s>$ + $_slice_h<@s>$ - 1;

                                exec betterworldedit:_do_subfill;

                                _slices<@s> = $_slices<@s>$ + 1;
                                _seg_idx<@s> = $_seg_idx<@s>$ + 1;
                            }
                        }
                        else {
                            // Y edges (8..11)
                            _iy<@s> = $_seg_idx<@s>$ * $_slice_h<@s>$; // offset along Y using slice_h
                            if $_iy<@s>$ >= $bwe_dim_y<@s>$ {
                                _seg_idx<@s> = 0; _ej<@s> = $_ej<@s>$ + 1;
                            } else {
                                _temp<@s> = $_slice_h<@s>$;
                                if $_temp<@s>$ > $bwe_dim_y<@s>$ - $_iy<@s>$ { _temp<@s> = $bwe_dim_y<@s>$ - $_iy<@s>$; }

                                // 8: x=min,z=min | 9: x=max,z=min | 10: x=min,z=max | 11: x=max,z=max
                                if $_ej<@s>$ == 8 { _xs<@s> = $bwe_min_x<@s>$; _xe<@s> = $bwe_min_x<@s>$; _zs<@s> = $bwe_min_z<@s>$; _ze<@s> = $bwe_min_z<@s>$; }
                                else {
                                    if $_ej<@s>$ == 9 { _xs<@s> = $bwe_max_x<@s>$; _xe<@s> = $bwe_max_x<@s>$; _zs<@s> = $bwe_min_z<@s>$; _ze<@s> = $bwe_min_z<@s>$; }
                                    else {
                                        if $_ej<@s>$ == 10 { _xs<@s> = $bwe_min_x<@s>$; _xe<@s> = $bwe_min_x<@s>$; _zs<@s> = $bwe_max_z<@s>$; _ze<@s> = $bwe_max_z<@s>$; }
                                        else { _xs<@s> = $bwe_max_x<@s>$; _xe<@s> = $bwe_max_x<@s>$; _zs<@s> = $bwe_max_z<@s>$; _ze<@s> = $bwe_max_z<@s>$; }
                                    }
                                }

                                _y_start<@s> = $bwe_min_y<@s>$ + $_iy<@s>$;
                                _y_end<@s>   = $_y_start<@s>$ + $_temp<@s>$ - 1;

                                exec betterworldedit:_do_subfill;

                                _slices<@s> = $_slices<@s>$ + 1;
                                _seg_idx<@s> = $_seg_idx<@s>$ + 1;
                            }
                        }
                    }

                    // Finish when all 12 edges are complete
                    if $_ej<@s>$ > 11 {
                        _fill_active<@s> = 0;
                        $!raw tellraw @s [{"text":"Done (outline edges) ","color":"green"},{"text":"(","color":"dark_gray"},{"score":{"name":"@s","objective":"_slices"},"color":"yellow"},{"text":" segments)","color":"gray"}] raw!$
                    }
                }
            }
        }
    }
}

// Public entrypoints
// =============================

// SOLID (renamed from fill_selection). Supports optional mask.
function betterworldedit:fill {
    $!raw
    data remove storage betterworldedit:ctx req
    data modify storage betterworldedit:ctx req set value {}
    data modify storage betterworldedit:ctx req.block set value "$(block)"
    # Optional mask compound may be included by caller; leave as-is in req.mask
    raw!$

    exec betterworldedit:_parse_mask;
    _op_mode<@s> = 1;
    exec betterworldedit:fill_block;
}

// Back-compat alias
function betterworldedit:fill_selection {
    $!raw
    data remove storage betterworldedit:ctx req
    data modify storage betterworldedit:ctx req set value {}
    data modify storage betterworldedit:ctx req.block set value "$(block)"
    raw!$

    exec betterworldedit:_parse_mask;
    _op_mode<@s> = 1;
    exec betterworldedit:fill_block;
}

// HOLLOW shell (6 faces). Supports mask.
function betterworldedit:fill_hollow {
    $!raw
    data remove storage betterworldedit:ctx req
    data modify storage betterworldedit:ctx req set value {}
    data modify storage betterworldedit:ctx req.block set value "$(block)"
    # Optional mask compound may be included by caller; leave as-is in req.mask
    raw!$

    exec betterworldedit:_parse_mask;
    _op_mode<@s> = 2;
    exec betterworldedit:fill_block_unified;
}

// OUTLINE edges (12). Supports mask.
function betterworldedit:fill_outline {
    $!raw
    data remove storage betterworldedit:ctx req
    data modify storage betterworldedit:ctx req set value {}
    data modify storage betterworldedit:ctx req.block set value "$(block)"
    # Optional mask compound may be included by caller; leave as-is in req.mask
    raw!$

    exec betterworldedit:_parse_mask;
    _op_mode<@s> = 3;
    exec betterworldedit:fill_block_unified;
}

// =============================
// Global config
// =============================

// Set the global max sub-fill size easily via storage argument: {value:NUMBER}
// Usage:
//   /function betterworldedit:set_max_fill {value:50000}
function betterworldedit:set_max_fill {
    exec betterworldedit:_ensure_global_config;
    $!raw
    scoreboard players set @e[type=armor_stand,tag=bwe_global_config,limit=1] bwe_max_fill $(value)
    tellraw @s [{"text":"Global max per sub-fill set to ","color":"gray"},{"score":{"name":"@e[type=armor_stand,tag=bwe_global_config,limit=1]","objective":"bwe_max_fill"},"color":"yellow"}]
    raw!$
}

// Set the global top-down fill mode via storage argument: {mode:NUMBER}
// Usage:
//   /function betterworldedit:set_topdown_mode {mode:0}  # Air only (default)
//   /function betterworldedit:set_topdown_mode {mode:1}  # Liquids + air
//   /function betterworldedit:set_topdown_mode {mode:2}  # All blocks
function betterworldedit:set_topdown_mode {
    exec betterworldedit:_ensure_global_config;
    $!raw
    scoreboard players set @e[type=armor_stand,tag=bwe_global_config,limit=1] bwe_topdown_mode $(mode)
    execute if score @e[type=armor_stand,tag=bwe_global_config,limit=1] bwe_topdown_mode matches 0 run tellraw @s [{"text":"Top-down fill mode: ","color":"gray"},{"text":"Air only","color":"aqua"}]
    execute if score @e[type=armor_stand,tag=bwe_global_config,limit=1] bwe_topdown_mode matches 1 run tellraw @s [{"text":"Top-down fill mode: ","color":"gray"},{"text":"Liquids + Air","color":"aqua"}]
    execute if score @e[type=armor_stand,tag=bwe_global_config,limit=1] bwe_topdown_mode matches 2 run tellraw @s [{"text":"Top-down fill mode: ","color":"gray"},{"text":"All blocks","color":"aqua"}]
    execute unless score @e[type=armor_stand,tag=bwe_global_config,limit=1] bwe_topdown_mode matches 0..2 run tellraw @s [{"text":"Invalid mode! Use 0 (air only), 1 (liquids+air), or 2 (all blocks)","color":"red"}]
    raw!$
}

// =============================
// Selector tools
// =============================

function betterworldedit:give_selector {
    $!raw
    give @s minecraft:brush[item_name={"bold":true,"color":"dark_blue","italic":true,"text":"BWE Selector (Pos1)"},lore=[{"text":"Right-click: set pos1","color":"gray","italic":false}],custom_data={bwe_selector_1:1b}] 1
    give @s minecraft:brush[item_name={"bold":true,"color":"gold","italic":true,"text":"BWE Selector (Pos2)"},lore=[{"text":"Right-click: set pos2","color":"gray","italic":false}],custom_data={bwe_selector_2:1b}] 1
    raw!$
    $!raw
    tellraw @s [{"text":"Gave you ","color":"gray"},{"text":"BWE Selector","color":"aqua","bold":true},{"text":" tools (pos1 & pos2)","color":"gray"}]
    raw!$
}

function betterworldedit:update_selector {
    // Update tags based on currently held selector tool
    $!raw
    tag @s remove bwe_holding_pos1
    tag @s remove bwe_holding_pos2
    execute if entity @s[nbt={SelectedItem:{components:{"minecraft:custom_data":{bwe_selector_1:1b}}}}] run tag @s add bwe_holding_pos1
    execute if entity @s[nbt={SelectedItem:{components:{"minecraft:custom_data":{bwe_selector_2:1b}}}}] run tag @s add bwe_holding_pos2
    raw!$

    // On brush use, run the appropriate function for whoever holds that tool, then reset the stat
    $!raw
    execute as @s[tag=bwe_holding_pos1,scores={bwe_use_selector=1..}] run function betterworldedit:pos1
    execute as @s[tag=bwe_holding_pos2,scores={bwe_use_selector=1..}] run function betterworldedit:pos2
    scoreboard players reset @s[scores={bwe_use_selector=1..}] bwe_use_selector
    raw!$
}
